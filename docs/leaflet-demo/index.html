<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WaterColorMap Demo</title>

    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>

    <style>
      html,
      body,
      #map {
        height: 100%;
        margin: 0;
      }
      .info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(255, 255, 255, 0.9);
        padding: 8px 10px;
        font:
          12px/1.4 system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          sans-serif;
        border-radius: 6px;
        z-index: 1000;
      }
    </style>
  </head>

  <body>
    <div id="map"></div>
    <div class="info">
      <div><strong>WaterColorMap</strong> demo</div>
      <div>Watercolor-inspired raster tiles (OSM data).</div>
    </div>

    <script>
      // Parse URL hash for initial view: #zoom/lat/lng
      function parseHash() {
        const hash = window.location.hash.replace("#", "");
        if (!hash) return null;
        const parts = hash.split("/");
        if (parts.length !== 3) return null;
        const zoom = parseInt(parts[0], 10);
        const lat = parseFloat(parts[1]);
        const lng = parseFloat(parts[2]);
        if (isNaN(zoom) || isNaN(lat) || isNaN(lng)) return null;
        return { zoom, lat, lng };
      }

      function updateHash(map) {
        const center = map.getCenter();
        const zoom = map.getZoom();
        const hash = `${zoom}/${center.lat.toFixed(5)}/${center.lng.toFixed(5)}`;
        history.replaceState(null, null, "#" + hash);
      }

      // Hanover-ish default view
      const defaultCenter = [52.375, 9.732];
      const defaultZoom = 13;

      const hashState = parseHash();
      const initialCenter = hashState ? [hashState.lat, hashState.lng] : defaultCenter;
      const initialZoom = hashState ? hashState.zoom : defaultZoom;

      const map = L.map("map", {
        center: initialCenter,
        zoom: initialZoom,
        minZoom: 0,
        maxZoom: 18,
      });

      // Update URL hash when map moves
      map.on("moveend", () => updateHash(map));

      // Custom tile layer with request cancellation on zoom change
      const WatercolorTileLayer = L.TileLayer.extend({
        _pendingRequests: new Map(),

        createTile: function (coords, done) {
          const tile = document.createElement("img");
          tile.alt = "";
          tile.setAttribute("role", "presentation");

          const url = this.getTileUrl(coords);
          const controller = new AbortController();
          const key = `${coords.z}/${coords.x}/${coords.y}`;

          // Track this request
          this._pendingRequests.set(key, { controller, done, tile });

          fetch(url, { signal: controller.signal })
            .then((response) => {
              if (!response.ok) throw new Error("Tile fetch failed");
              return response.blob();
            })
            .then((blob) => {
              tile.src = URL.createObjectURL(blob);
              this._pendingRequests.delete(key);
              done(null, tile);
            })
            .catch((err) => {
              this._pendingRequests.delete(key);
              // Don't call done() on abort - Leaflet has already cleaned up
              if (err.name !== "AbortError") {
                done(err, tile);
              }
            });

          return tile;
        },

        _abortPendingForZoom: function (oldZoom) {
          // Abort only requests for the OLD zoom level we're leaving
          for (const [key, { controller }] of this._pendingRequests) {
            const z = parseInt(key.split("/")[0], 10);
            if (z === oldZoom) {
              controller.abort();
              this._pendingRequests.delete(key);
            }
          }
        },
      });

      const tiles = new WatercolorTileLayer("", {
        attribution: "Â© OpenStreetMap contributors",
        maxZoom: 18,
      });

      tiles.getTileUrl = function ({ x, y, z }) {
        const dpr = window.devicePixelRatio || 1;
        const suffix = dpr >= 2 ? "@2x" : "";
        return `${window.location.origin}/tiles/z${z}_x${x}_y${y}${suffix}.png`;
      };

      // Cancel pending requests for the OLD zoom level when zoom changes
      map.on("zoomstart", () => {
        // At zoomstart, getZoom() returns the OLD zoom - which is what we want to cancel
        const oldZoom = map.getZoom();
        tiles._abortPendingForZoom(oldZoom);
      });

      tiles.addTo(map);

      // Set initial hash if not present
      if (!window.location.hash) {
        updateHash(map);
      }
    </script>
  </body>
</html>
