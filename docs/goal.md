# Plan for Creating Watercolor-Style Map Tiles in Go (Hanover Example)

To build a **Stamen Watercolor-style map** for Hanover (Niedersachsen) and eventually global coverage, we can break the project into clear phases. Each phase focuses on a key part of the pipeline - from data prep to rendering, image processing, and deployment. This approach replicates the _"old school"_ Stamen method (raster-based styling with hand-crafted textures[\[1\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=To%20begin%20with%2C%20we%20wanted,we%E2%80%99re%20actually%20running%20this%20process)) using **modern tools (Go, updated data, etc.)**. Below is a comprehensive plan with phased steps:

## Phase 1: Data Preparation and Tool Setup

**1\. Gather Up-to-Date Map Data:** Use **OpenStreetMap (OSM)** as the primary data source (as Stamen did[\[2\]](https://github.com/stamen/watercolor#:~:text=Watercolor%20is%20made%20up%20of,0%20and%20OpenStreetMap)). For the test area (Hanover), obtain an extract of OSM data covering the city and surroundings. Options include:

- **Download OSM extract** (e.g. from Geofabrik's region downloads or via Overpass API) for _Hanover, Lower Saxony_. This will provide streets, water bodies, parks, buildings, etc. in that area.
- For global expansion later, plan to use larger OSM extracts or the entire planet file, possibly filtered or regionalized. Also consider incorporating **Natural Earth** data for small-scale (world/continent) features, since Stamen's original style used Natural Earth for country outlines and such[\[2\]](https://github.com/stamen/watercolor#:~:text=Watercolor%20is%20made%20up%20of,0%20and%20OpenStreetMap).

**2\. Set Up a Spatial Database (optional but "old-school"):** For a classic approach, import OSM data into a **PostGIS** database. Tools like **osm2pgsql** can load OSM .pbf files into PostgreSQL/PostGIS[\[3\]](https://github.com/stamen/watercolor#:~:text=Software%20Dependencies%20). A database makes it easier to query and style specific feature classes (water, roads, green areas, etc.). If you prefer not to use a DB for the prototype, you could parse OSM data directly using a Go library (e.g. osmpbf or go-osm) - but using PostGIS is robust and aligns with the original Stamen workflow. It's the "old-school" method, ensuring reliable spatial queries and indexing.

**3\. Install Map Rendering Tools:** The core rendering engine in Stamen's pipeline was **Mapnik**, which produces the base images of the map[\[4\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=First%2C%20we%20render%20out%20some,extraordinarily%20vibrant%20Mapnik%20images). Mapnik has bindings for Python (used in the original), but you can leverage it in Go via bindings or use it through command-line utilities. Options:

- Install **Mapnik** and possibly its Go bindings (e.g. the go-mapnik library or **Gopnik**). Gopnik is a Go-based tile server that calls Mapnik under the hood[\[5\]](https://shinesolutions.com/2016/12/30/generating-high-res-maps-with-mapnik-and-docker/#:~:text=,opportunity%20to%C2%A0hack%20with%20it%C2%A0a%20bit), demonstrating that Mapnik can be integrated into a Go workflow. Using Mapnik will save you from writing low-level rendering routines and allow using styles (like CartoCSS or XML) to define map layers.
- Alternatively, investigate pure-Go map rendering libraries. However, these are less mature for complex cartography. Given the complexity of features (roads, landuse, water polygons), Mapnik (or similar, like Mapbox's tools) is the reliable choice to **render vector data to images** with custom styling.

**4\. Prepare Watercolor Textures:** You mentioned having **seamless watercolor textures** - ensure these are ready and tileable. These will be used as the _painting background_ for different map features. For now, a generic set (e.g. one texture) can be reused across features, but ideally gather a few textures (e.g. a blue-ish one for water, green for parks, earthy tones for land) to better mimic the original style. The Stamen team actually hand-painted and scanned various colored swatches for each feature type[\[6\]](https://stamen.com/watercolor-textures-15de97a4ad8b/#:~:text=For%20oceans%2C%20I%20painted%20a,mixed%20with%20turquoise%20and%20violet)[\[7\]](https://stamen.com/watercolor-textures-15de97a4ad8b/#:~:text=Oranges%2C%20reds%20and%20browns%20for,fading%20in%20and%20out%20underneath), making seamless tiles for each color. You need not paint new ones if you have some; just ensure they tile without seams and have the desired color tone or can be colorized in software.

**5\. Development Environment:** Use Linux/Ubuntu as planned, with Go for custom tooling. Ensure you have image processing libraries available for Go (or CLI tools like ImageMagick if you choose to prototype outside Go initially). For Go, libraries like image/draw (in stdlib) or third-party packages (e.g. github.com/disintegration/gift for filters, github.com/fogleman/gg for drawing) can be very helpful for applying blurs, noise, etc., if you implement those steps in pure Go.

## Phase 2: Rendering Base Map Layers (Mapnik Styling in Go)

**1\. Define Map** Layers**_\* and_ \*Styles:** Decide which feature layers you want to depict and their visual hierarchy. Based on Stamen's watercolor map, typical layers include: - **Land/background** (e.g. land masses or urban areas), - **Water bodies** (oceans, rivers), - **Green spaces** (parks, forests), - **Civic areas** (perhaps dense urban areas or buildings - in Stamen's maps these were tinted lavender-gray[\[8\]](https://stamen.com/watercolor-textures-15de97a4ad8b/#:~:text=Image)), - **Roads and highways** (major roads in warm colors[\[7\]](https://stamen.com/watercolor-textures-15de97a4ad8b/#:~:text=Oranges%2C%20reds%20and%20browns%20for,fading%20in%20and%20out%20underneath), minor roads possibly blended in), - Optionally, **labels** (Stamen watercolor _omitted labels_ for a pure artistic look, but you can add labels later as a separate layer if needed, likely using a more standard font or even an overlay from another source).

Start with the core areas: land, water, parks, and major roads. Each will become a separate _raster layer_ in the compositing step.

**2\. Create a Mapnik Style (CartoCSS or XML):** The idea is to render each of those layers in **flat, solid colors** (high contrast, distinct colors) so they can be isolated as masks for post-processing[\[4\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=First%2C%20we%20render%20out%20some,extraordinarily%20vibrant%20Mapnik%20images). For example, you might style: - Land areas (everything that's not water) as solid _yellow_ on a black background. - Water areas as solid _blue_, - Parks/forests as solid _green_, - Roads as solid _red_ (or white, depending on what's easier to mask later).

These bright colors are just placeholders to help in extracting masks. In the Stamen process, they rendered an initial bright Mapnik image and then "grabbed all the yellow" to mask land[\[4\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=First%2C%20we%20render%20out%20some,extraordinarily%20vibrant%20Mapnik%20images), subtracting out blue areas (water) from it[\[9\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Image). You can follow that approach: - **Single-pass method:** Render one composite image per tile with all features in different colors, then programmatically separate each color into its own mask layer (and handle overlaps like land vs water by color subtraction[\[9\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Image)). - **Multi-pass method:** Alternatively, render separate images for each category by toggling layers on/off in Mapnik. For instance, generate a PNG of just land polygons, then a PNG of just water, etc. This might be simpler to implement (no need to color-separate in code) at the cost of multiple renderings per tile. The process is still deterministic and yields the same result[\[10\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=people%20look%20at,multiple%20times%20for%20each%20tile). Given modern computing power and the limited test region, multiple passes per tile are fine (Stamen also ran multiple passes for ground, water, green space, etc., per tile[\[10\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=people%20look%20at,multiple%20times%20for%20each%20tile)).

If using Mapnik via Go, you would load these styles (CartoCSS or XML style definitions) in your Go program using the Mapnik bindings, then render each tile's image. If Mapnik setup in Go proves tricky, you could prototype by using Mapnik's Python binding or a tool like **TileMill/Carto** to render some sample images, then later integrate into Go. The key is to get a correct flat-color depiction of each feature layer at various zoom levels.

**3\. Tile Coordinate System:** Use the standard Web Mercator projection (EPSG:3857) and the Slippy Map tiling scheme (z/x/y). Ensure your rendering queries the data appropriately for each tile's bounding box. Libraries like **mercantile** (Python) or Go's maps/tile helpers can compute tile bounds. If using PostGIS, you might use something like ST_Intersect(tile_bbox, geometry) in your query to get features for that tile. If using a Go library to parse OSM, you'd need to filter geometries by the tile bbox.

Start with a moderate **zoom range** for Hanover (e.g. zoom levels 12-15 to see city detail, plus maybe 10-11 for regional view). You can adjust as needed. Lower zoom (world view) might need different data (that's where Natural Earth or generalized data would come in, but focus on city scale first).

**4\. Test a Single Tile or Area:** As a first milestone, try rendering a **single Mapnik image** covering Hanover to see if your styling is correct. For example, pick one tile (or a small range of tiles) at zoom ~13 that covers central Hanover. Verify that: - Land areas are correctly colored (e.g. all non-water is yellow), - Water is blue and aligns with rivers/lakes, - Parks are green in the correct locations (e.g. Maschpark or Eilenriede forest in Hanover), - Roads (maybe just major roads to start) appear in a distinct color. This test ensures your data and style are working. It's easier to debug on one image before generating many.

## Phase 3: Image Processing - Creating the Watercolor Effect

With flat color map images (or separate layer images) in hand, the next phase is to **apply the watercolor filter pipeline** to each layer. This is where you implement the artistic steps described by Stamen[\[11\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Next%2C%20we%20do%20a%20gaussian,blur)[\[12\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Now%20we%20do%20a%20threshold,a%20new%2C%20fuzzier%2C%20wobblier%20outline):

**1\. Generate a Fuzzy Mask:** Take the binary mask of a feature (e.g. land vs background). If you rendered separate images per layer, you can get this mask by converting that layer's image to grayscale or a binary (e.g. anything non-black = feature). If you used the multi-color single image method, isolate the color range for the feature (e.g. extract yellow areas for land) to make a mask. Once you have a binary mask (feature vs transparent), apply: - **Gaussian Blur:** Blur the mask slightly to soften edges[\[11\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Next%2C%20we%20do%20a%20gaussian,blur). This simulates the bleeding of watercolor on paper. Choose a radius that gives noticeable spread beyond the original edge (the Stamen team experimented with this; a small radius gives a subtle effect, a larger radius exaggerates the bleed). - **Add Perlin Noise:** Introduce randomness by combining a **tileable Perlin noise** texture with the blurred mask[\[13\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Image). Practically, you can have a pre-generated 1024×1024 noise image (as Stamen did[\[13\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Image)) and tile or position it such that each map tile gets a portion of noise. The noise can be added to the pixel values of the blurred mask (e.g. treat noise as an offset to make edges irregular). This step creates **uneven, wobbly edges** rather than a perfect smooth blur. - **Threshold:** After adding noise, **threshold** the image to convert it back into a sharp mask[\[12\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Now%20we%20do%20a%20threshold,a%20new%2C%20fuzzier%2C%20wobblier%20outline). Essentially, you decide a cutoff level: pixels above that brightness become fully opaque, below become transparent. This yields a new mask with an irregular coastline/outline. The thresholded mask is "fuzzier and wobblier" than the original[\[12\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Now%20we%20do%20a%20threshold,a%20new%2C%20fuzzier%2C%20wobblier%20outline), capturing that hand-painted feel. - **Antialias (Optional):** You might do a light blur or other antialiasing on the mask edges to avoid a jagged pixel look after thresholding[\[12\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Now%20we%20do%20a%20threshold,a%20new%2C%20fuzzier%2C%20wobblier%20outline). The goal is a clean but organic edge.

Implementing these in Go: you can use an imaging library to apply a Gaussian convolution. Perlin noise can be generated via an algorithm (there are Go implementations for Perlin noise) or simply load a noise image and blend it. Blending can be done by iterating pixels or using a library that supports layer compositing (e.g. multiply or add blending mode). Keep the noise tile consistent across adjacent map tiles to avoid seams - because the process **must be deterministic across tile boundaries**[\[10\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=people%20look%20at,multiple%20times%20for%20each%20tile). One trick is to always align the noise texture to the tile grid (e.g. the noise image's origin aligns with some global 0,0 in the map coordinate space) so that adjacent tiles pick up noise from the correct offset and the pattern matches at edges.

**2\. Apply Mask to Watercolor Texture:** Now use the processed mask to cut out the shape from your **watercolor texture**. For example, take your seamless watercolor image (e.g. a scan of painted paper) and tile it or scale it to the tile size. Then apply the mask as an alpha channel: the textured color will show only where the mask is opaque[\[14\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Which%20gets%20applied%20to%20a,tileable%20watercolor%20image). This gives the effect that the land (or water, park, etc.) is "painted" with that watercolor wash. Because the mask edges are irregular, the texture's color will fade out in a natural way at the boundaries.

_Color Tints:_ If you only have a generic texture (say a neutral paper with washes), you can tint the texture for each layer. For instance, multiply the texture by a solid color (blue for water, green for parks, etc.) _before_ applying the mask. Alternatively, prepare separate pre-colored textures. The original Stamen project created distinct colored texture tiles for each feature type and zoom level (e.g. different green textures for parks, blue for water) to achieve richer results[\[15\]](https://stamen.com/watercolor-textures-15de97a4ad8b/#:~:text=leaving%20me%20to%20focus%20primarily,the%20movement%20of%20the%20oceans). For a start, you might use one texture and just colorize it per layer in software - it's simpler than managing dozens of hand-painted textures.

**3\. Edge Darkening Effect:** An optional but authentic touch is to add the **dark outline of dried pigment** along edges of shapes[\[16\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=The%20other%20fancy%20bit%20of,gaussian%20blur%20of%20the%20mask). Stamen did this to mimic how watercolor paint concentrates at the edges when it dries. To do this for a layer: - Take the **original (sharp) mask** of the feature and use it to find the edges (for example, subtract or XOR the blurred version from the original to isolate just the border region, or use a morphological edge detect). - Or, as Stamen described: blur the mask a second time (a wider blur), then use the original crisp mask as a stencil to take only the outer "halo" part of that blurred mask[\[16\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=The%20other%20fancy%20bit%20of,gaussian%20blur%20of%20the%20mask). This produces a thick outline shape where original mask had edges. - Invert that outline's alpha and apply it to the blurred image to taper the effect[\[17\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Image) (Stamen inverted and used it as an alpha channel to avoid overweighting small areas[\[17\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Image)). - Color this outline slightly darker than the interior. For instance, if your land texture is beige, you could overlay a darker brown trace along its borders. Technically, you create an **overlay layer** by taking that edge mask and multiplying it with a dark color, then compositing it on top of the painted layer[\[18\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=This%20is%20then%20added%20as,the%20masked%20image%20from%20before).

This step is somewhat advanced. You can experiment with or without it; but including it will noticeably improve the authenticity of the watercolor look, as seen in Stamen's maps. You might implement this using image processing (convolutions to get edges, etc.). Test on a small area to fine-tune the thickness and darkness of edges.

By the end of Phase 3, for each feature category (land, water, park, etc.) you will have a **textured, watercolor-style raster layer** (a PNG image) for each tile. For example, tile X/Y/Z for land, tile X/Y/Z for water, etc., each with transparency around the painted areas.

## Phase 4: Compositing Layers and Tile Delivery

**1\. Composite Layers into Final Tiles:** Now combine the individual layer images into one final map tile. This means overlaying the painted layers in the correct order. A typical draw order (bottom to top) could be: - **Water layer** (blue watercolor) - as the bottom, since oceans/rivers form the backdrop where there is no land. - **Land layer** (earth-toned watercolor) - drawn above water. If your land mask had water areas cut out (no overlap), then water will show through wherever there's no land. If not, ensure the land layer is partially transparent or use the masks such that water areas don't get covered inadvertently. - **Parks/Greenery** (green texture) - drawn on top of land, so that parks have their own color on top of the generic land color. - **Civic/buildings** (if used) - perhaps drawn above land as well (depending on if you rendered buildings as a separate mask, they can overlay the base land color with a subtle gray/purple hue). - **Roads** - typically on top. Major roads could be represented by semi-transparent strokes or lighter-colored washes so they stand out. In Stamen's watercolor, highways had orange/red-brown strokes that were painted on top[\[7\]](https://stamen.com/watercolor-textures-15de97a4ad8b/#:~:text=Oranges%2C%20reds%20and%20browns%20for,fading%20in%20and%20out%20underneath). You can achieve this by using your road mask to cut out from a reddish watercolor texture (or tint) and overlaying it. Because roads are linear features, you might need to ensure the line widths scale with zoom and their watercolor effect uses a suitably thin blur so they don't become too blurry. - **Labels** - if you incorporate labels (optional for now), you would overlay text drawn with a regular font. This could be done via Mapnik (as a separate text layer) _before_ you do the watercolor filtering (i.e., maybe use a nice serif font with a slight transparency). However, labels might clash with the artistic style; consider leaving them out initially or serve labels from another tile source (some folks overlay a transparent label layer on top of watercolor tiles).

Perform the compositing in the correct sequence using an image library (ensuring each layer aligns pixel-perfectly). All layers and textures should be **tile-aligned and edge-consistent** so that when tiles meet each other in Leaflet, features line up and no seams are visible. The deterministic processing and tileable textures from earlier steps are what guarantee seamless edges[\[10\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=people%20look%20at,multiple%20times%20for%20each%20tile). For example, using the same Perlin noise pattern on adjacent tiles means a road crossing from one tile to the next will have a continuous wobbly edge, not a jarring shift.

After compositing, each output is a **256×256 px (or 512×512 for Hi-DPI) PNG tile** ready for web maps. Verify a few manually - e.g. overlay the tiles in a simple Leaflet page for Hanover and confirm the look (colors, alignment, etc.) is as expected.

**2\. Leaflet Integration (Test Locally):** To see the results, set up a basic Leaflet map pointing to your tile URLs. For example, if you host tiles on a local server or just as files:

L.tileLayer('<http://localhost:8000/tiles/{z}/{x}/{y}.png>', {  
maxZoom: 15, minZoom: 10, attribution: '© OpenStreetMap contributors'  
}).addTo(map);

Serve the tiles/ directory via a simple static file server (or even use a python -m http.server or a small Go HTTP server). Load the Leaflet page and pan/zoom around Hanover to inspect your watercolor tiles. This is the reward moment - you should see familiar shapes (roads, rivers, parks) rendered in a beautiful watercolor style unique to your data!

**3\. Iterate on Visual Tuning:** At this stage, you might refine parameters: - Adjust blur radius or threshold level if edges are too crisp or too washed out. - Try different watercolor textures for different layers (maybe the park green looks too similar to land, etc.). - Tweak color saturation or brightness by post-processing the tile (e.g. if overall map looks too light/dark). - Ensure tile edge matching: if you notice any seams at tile borders, adjust the noise alignment or mask process. The process being _entirely deterministic per tile_ is meant to prevent seams[\[10\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=people%20look%20at,multiple%20times%20for%20each%20tile), so any seam indicates something nondeterministic (like a random seed per tile) - fix by using consistent inputs across tiles.

Focus on getting the Hanover tiles looking good. Once you're satisfied, you have a proven method to expand.

## Phase 5: Scaling Up and Modern Improvements (Global Map)

After the prototype, consider how to **scale this globally and add a modern twist**:

**1\. Data Scaling:** For covering larger regions or the whole world, manage data carefully. A single PostGIS database with the whole planet can be huge, so you might: - Use **regional databases** or import only necessary features (you might not need every minor detail for watercolor at small scales). - Or use **vector tile inputs**: Modern approach could be to pre-generate vector tiles (like an MBTiles of OSM data) and then render those on the fly with your style. However, doing the full watercolor effect dynamically for each tile might be too slow without precomputation - so sticking to raster pre-render is safer for now.

**2\. Parallel Tile Rendering:** Writing the pipeline in Go offers the advantage of concurrency. You can generate tiles in parallel by dividing the tile grid among goroutines or workers. This will speed up processing, especially for a large area. If using a DB, be mindful of not overloading it; you may need to throttle or replicate the database for heavy read load.

**3\. Automating Tile Generation:** If going global, you'll likely script the tile generation by zoom ranges: - Low zooms (0-5): use generalized data (Natural Earth) and maybe a different style (broad strokes of color). - Mid zooms (6-9): country/province level detail (major rivers, cities). - High zooms (10+): use detailed OSM features, possibly up to zoom 17-18 if you want street-level watercolor (though Stamen's watercolor was limited in maximum zoom because it gets hard to render very fine details in this style). - You don't have to do all at once; start with mid-range zooms that show the effect well. Add higher zooms once the basics are working.

It might make sense to generate an **MBTiles** (a single file SQLite tile store) for easier distribution of your custom tiles. There are tools (like mbutil or tilepacker) that can pack folder tiles into MBTiles. This is optional but helpful for uploading to tile hosting or for archival.

**4\. Tile Hosting:** For the final deployment, decide on a hosting strategy: - **Self-hosting:** You can run a tile server on a cloud VM or your own server. Given the tiles are static images, a simple CDN or web server can suffice. For example, you could upload the tile folder to Amazon S3 or Azure Blob Storage and serve via a CDN (CloudFront, etc.) for global performance. This is basically hosting the tiles as static files. - **Third-party providers:** Some services allow hosting custom tiles. Since Stamen's watercolor tiles are now also hosted by Stadia Maps[\[19\]](https://github.com/stamen/watercolor#:~:text=,com%2Fstamen), similarly you could use a service like Mapbox or MapTiler Cloud by uploading your tile set. Ensure the provider supports raster tile hosting (many now focus on vector tiles). - **On-the-fly rendering service:** A more dynamic approach is to set up a Go tile server (maybe using the aforementioned Gopnik or a custom service) that generates tiles on request and caches them. This saves storage (you don't pre-render everything, just what's viewed), but it means any cache miss triggers the full rendering pipeline. Given the heavy image processing (blur, noise), you'd need a powerful server or cluster for real-time rendering, or at least generate popular areas in advance.

For initial testing on Hanover, self-host on your own machine or a small server - that's fine. For global, plan a robust hosting to handle user load (if this map goes public) and bandwidth, as watercolor tiles can be somewhat larger in size than vector tiles.

**5\. Updating Data:** One modern improvement over the old Stamen tiles is to have **up-to-date data**. OSM is continuously updated. Consider how you will update your map data periodically: - You might set up a pipeline to re-run the tile generation for areas that changed. Using diffs in OSM is complex, so possibly a full re-render monthly or so might be acceptable. - If using a PostGIS DB, you can apply minutely diffs to keep it current and then render only new tiles. This is advanced; an alternative is to rebuild tiles from scratch on a schedule (since you control the process and style).

**6\. Additional Features / Enhancements:** Once the basic style is working, you have room for enhancements: - **Different Textures:** Incorporate more of the hand-crafted feel by using multiple textures. The Stamen team created unique textures per zoom level and feature[\[15\]](https://stamen.com/watercolor-textures-15de97a4ad8b/#:~:text=leaving%20me%20to%20focus%20primarily,the%20movement%20of%20the%20oceans). You could similarly use a coarse paper texture for low zoom (to look like a broad wash) and finer detail textures for high zoom (to show detailed brush strokes). - **Lighting/Relief:** Some stylized maps add hillshading or paper grain. A _modern twist_ could be using a shaded relief layer (from DEM data) lightly blended to give terrain a subtle presence beneath the watercolor - careful not to overdo, or it might conflict with the aesthetic. - **Interactivity and Vector Data:** Another modern approach would be to use vector data for interactivity (so you could highlight features or label them on hover). Your raster tiles won't inherently support that, but you could run a parallel vector tile service (for example, an invisible layer for clicking, or just rely on Leaflet's vector OSM queries for info). This is extra and not necessary for the visual result, but worth noting as a future expansion.

Finally, document your process and tools as you go. The original Watercolor project lacked documentation initially[\[20\]](https://github.com/stamen/watercolor#:~:text=Originally%2C%20Stamen%20never%20planned%20to,but%20documentation%20is%20still%20lacking), but you now have a plan to follow. By the end of these phases, you should have a beautiful **Hanover watercolor map** running in Leaflet. From there, you can gradually extend coverage, optimize performance, and deploy widely. Good luck blending the _old-school_ artistry with modern tech - with Go and updated data, your custom watercolor tiles can recapture that charm with a fresh, current twist!

**Sources:**

- Stamen Design, _"Watercolor Process"_ (2012) - Describes the step-by-step algorithm for generating watercolor-style map tiles[\[11\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Next%2C%20we%20do%20a%20gaussian,blur)[\[12\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Now%20we%20do%20a%20threshold,a%20new%2C%20fuzzier%2C%20wobblier%20outline)[\[14\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Which%20gets%20applied%20to%20a,tileable%20watercolor%20image)[\[21\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Image).
- Stamen Design, _"Watercolor Textures"_ (2012) - Discusses creation of hand-painted textures for the map, one per feature type and zoom level[\[15\]](https://stamen.com/watercolor-textures-15de97a4ad8b/#:~:text=leaving%20me%20to%20focus%20primarily,the%20movement%20of%20the%20oceans)[\[6\]](https://stamen.com/watercolor-textures-15de97a4ad8b/#:~:text=For%20oceans%2C%20I%20painted%20a,mixed%20with%20turquoise%20and%20violet).
- Stamen 'Watercolor' GitHub README - Notes that the map style uses OpenStreetMap and Natural Earth data, rendered via Mapnik and served with TileStache (old stack)[\[2\]](https://github.com/stamen/watercolor#:~:text=Watercolor%20is%20made%20up%20of,0%20and%20OpenStreetMap)[\[3\]](https://github.com/stamen/watercolor#:~:text=Software%20Dependencies%20).
- Shine Solutions Blog, _"Generating high-res maps with Mapnik and Docker"_ - An example of integrating Mapnik rendering with a Go-based server (Gopnik)[\[5\]](https://shinesolutions.com/2016/12/30/generating-high-res-maps-with-mapnik-and-docker/#:~:text=,opportunity%20to%C2%A0hack%20with%20it%C2%A0a%20bit), illustrating that Mapnik can be called from Go for custom tile generation.

[\[1\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=To%20begin%20with%2C%20we%20wanted,we%E2%80%99re%20actually%20running%20this%20process) [\[4\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=First%2C%20we%20render%20out%20some,extraordinarily%20vibrant%20Mapnik%20images) [\[9\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Image) [\[10\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=people%20look%20at,multiple%20times%20for%20each%20tile) [\[11\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Next%2C%20we%20do%20a%20gaussian,blur) [\[12\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Now%20we%20do%20a%20threshold,a%20new%2C%20fuzzier%2C%20wobblier%20outline) [\[13\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Image) [\[14\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Which%20gets%20applied%20to%20a,tileable%20watercolor%20image) [\[16\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=The%20other%20fancy%20bit%20of,gaussian%20blur%20of%20the%20mask) [\[17\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Image) [\[18\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=This%20is%20then%20added%20as,the%20masked%20image%20from%20before) [\[21\]](https://stamen.com/watercolor-process-3dd5135861fe/#:~:text=Image) Watercolor Process | Stamen

<https://stamen.com/watercolor-process-3dd5135861fe/>

[\[2\]](https://github.com/stamen/watercolor#:~:text=Watercolor%20is%20made%20up%20of,0%20and%20OpenStreetMap) [\[3\]](https://github.com/stamen/watercolor#:~:text=Software%20Dependencies%20) [\[19\]](https://github.com/stamen/watercolor#:~:text=,com%2Fstamen) [\[20\]](https://github.com/stamen/watercolor#:~:text=Originally%2C%20Stamen%20never%20planned%20to,but%20documentation%20is%20still%20lacking) GitHub - stamen/watercolor

<https://github.com/stamen/watercolor>

[\[5\]](https://shinesolutions.com/2016/12/30/generating-high-res-maps-with-mapnik-and-docker/#:~:text=,opportunity%20to%C2%A0hack%20with%20it%C2%A0a%20bit) Generating high-res maps with Mapnik and Docker - Shine Solutions Group

<https://shinesolutions.com/2016/12/30/generating-high-res-maps-with-mapnik-and-docker/>

[\[6\]](https://stamen.com/watercolor-textures-15de97a4ad8b/#:~:text=For%20oceans%2C%20I%20painted%20a,mixed%20with%20turquoise%20and%20violet) [\[7\]](https://stamen.com/watercolor-textures-15de97a4ad8b/#:~:text=Oranges%2C%20reds%20and%20browns%20for,fading%20in%20and%20out%20underneath) [\[8\]](https://stamen.com/watercolor-textures-15de97a4ad8b/#:~:text=Image) [\[15\]](https://stamen.com/watercolor-textures-15de97a4ad8b/#:~:text=leaving%20me%20to%20focus%20primarily,the%20movement%20of%20the%20oceans) Watercolor Textures | Stamen

<https://stamen.com/watercolor-textures-15de97a4ad8b/>